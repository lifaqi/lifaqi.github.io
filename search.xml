<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习之MNIST]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BMNIST%2F</url>
    <content type="text"><![CDATA[1、数据下载链接:https://pan.baidu.com/s/13iaQNaYFsBJO6uQH6wX2lg 密码:ek1m 2、Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import input_dataimport tensorflow as tf# 加载MNIST数据mnist = input_data.read_data_sets('MNIST_data', one_hot=True)# 运行TensorFlow的InteractiveSessionsess = tf.InteractiveSession()# 占位符x = tf.placeholder("float", shape=[None, 784])y_ = tf.placeholder("float", shape=[None, 10])# 权重初始化def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)'''卷积和池化我们的卷积使用1步长（stride size），0边距（padding size）的模板，保证输出和输入是同一个大小。我们的池化用简单传统的2x2大小的模板做max pooling。为了代码更简洁，我们把这部分抽象成一个函数。'''def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME')'''第一层卷积卷积在每个5x5的patch中算出32个特征。卷积的权重张量形状是[5, 5, 1, 32]，前两个维度是patch的大小，接着是输入的通道数目，最后是输出的通道数目。 而对于每一个输出通道都有一个对应的偏置量。'''W_conv1 = weight_variable([5, 5, 1, 32])b_conv1 = bias_variable([32])x_image = tf.reshape(x, [-1,28,28,1])h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)h_pool1 = max_pool_2x2(h_conv1)'''第二层卷积为了构建一个更深的网络，我们会把几个类似的层堆叠起来。第二层中，每个5x5的patch会得到64个特征。'''W_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2)'''密集连接层现在，图片尺寸减小到7x7，我们加入一个有1024个神经元的全连接层，用于处理整个图片。我们把池化层输出的张量reshape成一些向量，乘上权重矩阵，加上偏置，然后对其使用ReLU。'''W_fc1 = weight_variable([7 * 7 * 64, 1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)'''Dropout为了减少过拟合，我们在输出层之前加入dropout。我们用一个placeholder来代表一个神经元的输出在dropout中保持不变的概率。这样我们可以在训练过程中启用dropout，在测试过程中关闭dropout。 TensorFlow的tf.nn.dropout操作除了可以屏蔽神经元的输出外，还会自动处理神经元输出值的scale。所以用dropout的时候可以不用考虑scale。'''keep_prob = tf.placeholder("float")h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)'''输出层最后，我们添加一个softmax层'''W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)'''训练和评估模型'''cross_entropy = -tf.reduce_sum(y_*tf.log(y_conv))train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float"))sess.run(tf.global_variables_initializer())for i in range(1000): batch = mnist.train.next_batch(50) if i % 100 == 0: train_accuracy = accuracy.eval(feed_dict=&#123; x: batch[0], y_: batch[1], keep_prob: 1.0&#125;) print("step %d, training accuracy %g" % (i, train_accuracy)) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)print("test accuracy %g" % accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;)) 这个最终结果值应该大约是96%，可以增加训练次数，可以增加正确率。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习之k-means聚类算法]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bk-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、k-means聚类算法简介k-means算法把数据集分成k个组，使每个组内具有较高的相似度。其处理过程如下： 1、随机选择k个点作为初始的聚类中心 2、对于剩下的点，根据其与聚类中心的距离，将其归入最近的组 3、对每个组，计算所有点的均值作为新的聚类中心 4、重复2、3直到聚类中心不再发生改变 2、数据源1999年全国31个省份城镇居民家庭平均每人全年消费性支出的八个主要变量数据，这八个变量分别是：食品、衣着、家庭设备用品及服务、医疗保健、交通和通讯、娱乐教育文化服务、居住以及杂项商品和服务。 下载地址：链接:https://pan.baidu.com/s/1ClND-R7rpx8M03TirkqXLw 密码:6tk6 3、实验目的通过聚类，了解1999年各个省份在国内的消费水平情况 4、代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import numpy as npfrom sklearn.cluster import KMeansdef load_data(file_path): """ 读取文件数据并返回消费数据和对应省份名称 :param file_path: 数据文件路径 :return: 各省消费数据,省份名称 """ file = open(file_path, 'r+', encoding='utf-8') # 注意读文件的编码 lines = file.readlines() file_data = [] file_city_name = [] for line in lines: items = line.strip().split(',') file_city_name.append(items[0]) file_data.append([float(items[i]) for i in range(1, len(items))]) file.close() return file_data, file_city_namedef save_data(file_path, file_data): """ 保存输出结果到指定路径下 :param file_path: 保存结果的目的文件路径 :param file_data: 结果数据 :return: """ file = open(file_path, 'w+', encoding='utf-8') # 注意编码 file.write(str(file_data)) file.close()data, city_name = load_data('data.csv')km = KMeans(n_clusters=3) # 将省份分3类label = km.fit_predict(data) # 计算簇中心以及为簇分配序号avgExpenses = np.sum(km.cluster_centers_, axis=1) # axis 1按行 2按列 求和# 根据label将相同分类省份名放置一起CityCluster = [[], [], []] # 创建3个数组存放数据，和分类数量对应for i in range(len(city_name)): CityCluster[int(label[i])].append(city_name[i])resultStr = '' # 保存分类结果# 输出分类结果for i in range(len(CityCluster)): print("每人每年的消费：￥%0.2f" % (avgExpenses[i])) print(CityCluster[i]) # 将同分类省份用,拼接 resultStr = resultStr + ','.join(CityCluster[i]) + '\n'# 保存分类结果save_data('result.csv', resultStr) 5、运行结果123456每人每年的消费：￥5113.54['天津', '江苏', '浙江', '福建', '湖南', '广西', '海南', '重庆', '四川', '云南', '西藏']每人每年的消费：￥3827.87['河北', '山西', '内蒙古', '辽宁', '吉林', '黑龙江', '安徽', '江西', '山东', '河南', '湖北', '贵州', '陕西', '甘肃', '青海', '宁夏', '新疆']每人每年的消费：￥7754.66['北京', '上海', '广东']]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Demo： 12345678910111213import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tfnum_points = 1000vectors_set = []for i in range(num_points): x1 = np.random.normal(0.0, 0.55) y1 = x1 * 0.1 + 0.3 + np.random.normal(0.0, 0.03) vectors_set.append([x1, y1])x_data = [v[0] for v in vectors_set]y_data = [v[1] for v in vectors_set] 1234567891011121314151617181920212223242526272829303132# Graphic displayplt.plot(x_data, y_data, &apos;ro&apos;)plt.legend()plt.show()W = tf.Variable(tf.random_uniform([1], -1.0, 1.0))b = tf.Variable(tf.zeros([1]))y = W * x_data + bloss = tf.reduce_mean(tf.square(y - y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train = optimizer.minimize(loss)init = tf.initialize_all_variables()sess = tf.Session()sess.run(init)for step in range(20): sess.run(train) print(step, sess.run(W), sess.run(b)) print(step, sess.run(loss)) # Graphic display plt.plot(x_data, y_data, &apos;ro&apos;) plt.plot(x_data, sess.run(W) * x_data + sess.run(b)) plt.xlabel(&apos;x&apos;) plt.xlim(-2, 2) plt.ylim(0.1, 0.6) plt.ylabel(&apos;y&apos;) plt.legend() plt.show() 效果图：]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git丢失文件找回]]></title>
    <url>%2FGit%E4%B8%A2%E5%A4%B1%E6%96%87%E4%BB%B6%E6%89%BE%E5%9B%9E%2F</url>
    <content type="text"><![CDATA[1、cd到项目文件目录下 2、查看git日志： 1$ git log 3、根据日志的编码，重置到之前正确的一次提交： 1$ git reset --hard 283f742b9c5bb3e10431205e43933b24286355f7 4、效果图：]]></content>
      <categories>
        <category>Git应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PyCharm2018破解]]></title>
    <url>%2FPyCharm2018%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、到官网去下载PyCharm 2、下载破解补丁 密码:sqgc 3、将补丁复制到你的PyCharm的安装目录下的lib文件夹中 4、在PyCharm安装目录下找到bin目录，然后进入bin文件夹找到pycharm.vmoptions文件，用记事本打开，在末尾一行追加： -javaagent:/Applications/PyCharm.app/Contents/lib/JetbrainsCrack-2.8-release-enc.jar 注：/Applications/PyCharm.app/Contents/lib/JetbrainsCrack-2.8-release-enc.jar是JetbrainsCrack-2.8-release-enc.jar的路径 5、打开你的PyCharm客户端，在Activation code界面中填入以下代码 ： 1234567891011121314151617181920212223242526&#123;&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,&quot;licenseeName&quot;:&quot;Rover12421&quot;,&quot;assigneeName&quot;:&quot;Rover12421&quot;,&quot;assigneeEmail&quot;:&quot;rover12421@163.com&quot;,&quot;licenseRestriction&quot;:&quot;By Rover12421 Crack, Only Test! Please support genuine!!!&quot;,&quot;checkConcurrentUse&quot;:false,&quot;products&quot;:[&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DB&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;GO&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RD&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;],&quot;hash&quot;:&quot;2911276/0&quot;,&quot;gracePeriodDays&quot;:7,&quot;autoProlongated&quot;:false&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python多线程threading]]></title>
    <url>%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8Bthreading%2F</url>
    <content type="text"><![CDATA[123456789101112import timeimport threadingimport requestsheaders = &#123; 'authorization': 'www.zhihu.com', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36', 'cookie': 'd_c0="ADCimU9GoA2PTuwqBBtf7zgvunKrfCVtv2A=|1526874149"; _zap=00e791df-6c80-4e35-80c4-2acffd67869f; q_c1=a4340fbcb86a444f9c0b089763296002|1526884622000|1526884622000; l_cap_id="YTEwZTFjODJiYWQ2NDk3M2I0NjVhMTFiZTJhYTVmZGU=|1526885234|daa6426325707c6423a8aa05baba3a2ea6e8ea60"; r_cap_id="ZTJkN2EwYWNlNTI5NDVkYWJhM2FmNWNmMzJjYmUwOTU=|1526885234|a4d99bee7fe65ac0bca9ca13890b548005854d45"; cap_id="MWMwNjBjMTNiYjMwNDEwZWEwZmY3MjQxOGE1NTZiNmM=|1526885234|ae7bc3b85097120806f19065a89a940a04055157"; capsion_ticket="2|1:0|10:1526888690|14:capsion_ticket|44:NGMwODJhMjQyODUzNGQ2ODk3MjgzYTgzNjlhNmI5Yjg=|913742186b626c392c95328db7fced52ea4633c7b24290589c66ab9ca70f2db1"; z_c0="2|1:0|10:1526888730|4:z_c0|92:Mi4xSFJjNENBQUFBQUFBTUtLWlQwYWdEU1lBQUFCZ0FsVk5Hc2Z2V3dCQldORkRDdXdINXFIdXBmcHliYVJMUExjdVJ3|384372d5e04e3497ebb7273823b1c12a9a5ee53e66324a06b852eb5404f3f9c0"; _xsrf=7fafb0c2-bd35-4f18-a243-d20d294ebb44; tgw_l7_route=860ecf76daf7b83f5a2f2dc22dccf049'&#125;URL = 'https://www.zhihu.com/api/v4/members/shen-wu-yue-72-74/followees? 123456789101112131415161718192021include=data%5B*%5D.answer_count,articles_count,gender,follower_count,is_followed,is_following,badge%5B?(type%3Dbest_answerer)%5D.topics&amp;offset=0&amp;limit=20'def job(): response = requests.get(URL, headers=headers).json() print(response)def main(): threads = [threading.Thread(target=job) for index in range(20)] for t in threads: t.start() for t in threads: t.join()if __name__ == '__main__': t1 = time.time() main() print("花费时间:", time.time() - t1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac系统显示/隐藏文件]]></title>
    <url>%2FMac%E7%B3%BB%E7%BB%9F%E6%98%BE%E7%A4%BA-%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、通过快捷键Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏 2、通过终端命令来显示或隐藏在终端（Terminal）输入如下命令： —显示文件 defaults write com.apple.finder AppleShowAllFiles -boolean true; killall Finder —隐藏文件 defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder 3、通过终端来查找打开终端，进入到要找的隐藏文件目录下，输入：ls -a，就可以看到所有的文件，包括隐藏文件]]></content>
      <categories>
        <category>Mac电脑应用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑怎么查看已连接WiFi的密码]]></title>
    <url>%2FMac%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%B7%B2%E8%BF%9E%E6%8E%A5WiFi%E7%9A%84%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、首先打开系统自带的”钥匙串访问“工具 2、点击左侧的”所有项目“ 3、查找WiFi的名字，由于里面的内容可能比较多，可以用右上角的搜索框进行搜索 4、双击后，弹出一个框，点击显示密码框 5、然后会弹出一个框，输入钥匙串密码 6、输入密码，确认后，就可以看到该WiFi的密码了。]]></content>
      <categories>
        <category>Mac电脑应用</category>
      </categories>
  </entry>
</search>
